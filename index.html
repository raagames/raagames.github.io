<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Existing head content -->
    <!-- Google tag (gtag.js) -->
    <!-- ... [Your existing head content remains unchanged] ... -->

    <!-- Include MediaPipe and necessary scripts -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <!-- Custom Cursor Style -->
    <style>
        body {
            cursor: none; /* Hide the default cursor */
            margin: 0;
            overflow: hidden;
        }
        #custom-cursor {
            position: absolute;
            width: 32px; /* Adjust the size as needed */
            height: 32px;
            background-image: url('cursor.png'); /* Replace with your cursor image */
            background-size: cover;
            background-repeat: no-repeat;
            pointer-events: none;
            transform: translate(-50%, -50%);
            z-index: 9999; /* Ensure the cursor stays on top */
        }
        /* Hide the video and canvas elements */
        #input_video, #output_canvas {
            display: none;
        }
    </style>
</head>
<body>
    <!-- Your existing content -->
    <!-- ... [Your existing content remains unchanged] ... -->

    <!-- Custom Cursor Element -->
    <div id="custom-cursor"></div>

    <!-- Video and Canvas Elements for Hand Tracking -->
    <video id="input_video" playsinline></video>
    <canvas id="output_canvas"></canvas>

    <!-- Hand Tracking and Cursor Control Script -->
    <script>
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const cursor = document.getElementById('custom-cursor');

        let isClicking = false;

        function distance(point1, point2) {
            const dx = point1.x - point2.x;
            const dy = point1.y - point2.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function onResults(results) {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];

                // Get index finger tip and thumb tip landmarks
                const indexFingerTip = landmarks[8];
                const thumbTip = landmarks[4];

                // Calculate the normalized distance between index finger tip and thumb tip
                const pinchDistance = distance(indexFingerTip, thumbTip);

                // Define a threshold for pinch gesture
                const pinchThreshold = 0.05; // Adjust this value as needed

                // Update cursor position
                cursor.style.left = `${indexFingerTip.x * window.innerWidth}px`;
                cursor.style.top = `${indexFingerTip.y * window.innerHeight}px`;

                // Check if pinch gesture is detected
                if (pinchDistance < pinchThreshold) {
                    if (!isClicking) {
                        isClicking = true;
                        // Simulate mouse down event
                        simulateMouseEvent('mousedown', indexFingerTip.x, indexFingerTip.y);
                    }
                } else {
                    if (isClicking) {
                        isClicking = false;
                        // Simulate mouse up event
                        simulateMouseEvent('mouseup', indexFingerTip.x, indexFingerTip.y);
                        // Simulate click event
                        simulateMouseEvent('click', indexFingerTip.x, indexFingerTip.y);
                    }
                }
            }

            canvasCtx.restore();
        }

        function simulateMouseEvent(eventType, x, y) {
            const event = new MouseEvent(eventType, {
                clientX: x * window.innerWidth,
                clientY: y * window.innerHeight,
                bubbles: true,
                cancelable: true,
                view: window
            });
            const element = document.elementFromPoint(event.clientX, event.clientY);
            if (element) {
                element.dispatchEvent(event);
            }
        }

        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });

        hands.onResults(onResults);

        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 640,
            height: 480
        });

        camera.start();
    </script>
</body>
</html>
